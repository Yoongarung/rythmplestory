<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>4키 리듬게임 (Mobile)</title>

  <style>
    :root{
      --glass: rgba(10,12,16,.62);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.65);

      --accent: rgba(120,220,255,.95);
      --good: rgba(140, 255, 180, .95);
      --warn: rgba(255, 216, 120, .95);
      --bad: rgba(255, 120, 120, .95);

      --laneGap: 10px;

      /* ✅ 모바일 가시성: 노트를 크게 */
      --noteH: 70px;

      /* ✅ 터치패드 */
      --padH: 150px;
      --padRadius: 18px;

      /* ✅ 판정 윈도우(패드 발광) 크기 */
      --hitGlowH: 70px;      /* 패드 상단으로부터 발광 높이 */
      --hitGlowOpacity: .9;  /* 기본 발광 강도 */

      --miniHUDH: 44px;
    }

    *{ box-sizing:border-box; }
    html, body{
      height:100%;
      margin:0;
      background:#0b0f14;
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial;
      overscroll-behavior: none;
      touch-action: none;
    }

    .app{
      height:100%;
      width:100%;
      position:relative;
      overflow:hidden;
      background:#0b0f14;
    }

    .bg{
      position:absolute; inset:0;
      background:#0b0f14 center/cover no-repeat;
      transform: scale(1.02);
      filter: saturate(1.05) contrast(1.05);
    }
    .bg::after{
      content:"";
      position:absolute; inset:0;
      background: radial-gradient(90% 70% at 50% 25%, rgba(0,0,0,.10), rgba(0,0,0,.62) 55%, rgba(0,0,0,.88));
    }

    .hud{
      position:relative;
      z-index:3;
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      padding: 10px 12px;
      padding-top: calc(10px + env(safe-area-inset-top));
      background: linear-gradient(to bottom, rgba(0,0,0,.62), rgba(0,0,0,.12));
      border-bottom: 1px solid rgba(255,255,255,.08);
    }
    .left, .right{ display:flex; align-items:center; gap:8px; flex-wrap:wrap; }

    .badge{
      background: rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 999px;
      padding: 6px 9px;
      font-size: 12px;
      color: var(--muted);
      display:flex; align-items:center; gap:7px;
      backdrop-filter: blur(10px);
      user-select:none;
      -webkit-user-select:none;
    }
    .badge strong{ color: var(--text); font-weight:800; }

    select, button{
      background: rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.16);
      color: var(--text);
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 13px;
      outline:none;
      backdrop-filter: blur(10px);
    }
    select{ padding-right: 26px; max-width: 48vw; }
    button{ cursor:pointer; user-select:none; -webkit-user-select:none; }
    button:active{ transform: translateY(1px); }

    .btnPrimary{
      background: rgba(120,220,255,.16);
      border-color: rgba(120,220,255,.40);
    }
    .btnDanger{
      background: rgba(255,120,120,.12);
      border-color: rgba(255,120,120,.35);
    }

    .stage{
      position:relative;
      z-index:2;
      height: calc(100% - 64px);
      padding-bottom: env(safe-area-inset-bottom);
      display:flex;
      align-items:stretch;
      justify-content:center;
    }

    .laneBoard{
      width: 100%;
      height: 100%;
      position:relative;
      background: rgba(0,0,0,.22);
      border-top: 1px solid rgba(255,255,255,.08);
      border-bottom: 1px solid rgba(255,255,255,.08);
      overflow:hidden;
    }

    .lanes{
      position:absolute; inset:0;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap: var(--laneGap);
      padding: 14px 12px 0;
      pointer-events:none;
      z-index: 5;
    }
    .lane{
      flex: 1 1 0;
      height:100%;
      position:relative;
      border-left: 1px solid rgba(255,255,255,.08);
      border-right: 1px solid rgba(255,255,255,.08);
      background: linear-gradient(to bottom, rgba(255,255,255,.04), rgba(255,255,255,.02));
      overflow:hidden;
      border-radius: 10px;
    }
    .lane::after{
      content:"";
      position:absolute;
      inset:-10px;
      opacity:0;
      pointer-events:none;
      background:
        radial-gradient(120% 92% at 50% 78%,
          rgba(120,220,255,.56),
          rgba(120,220,255,.30) 46%,
          transparent 74%),
        linear-gradient(to bottom,
          rgba(120,220,255,.34),
          rgba(120,220,255,.14) 40%,
          transparent 76%);
      filter: saturate(1.45) brightness(1.14);
      transition: opacity .06s ease;
    }
    .lane.lit::after{ opacity: .75; }

    /* ✅ 노트 */
    .note{
      position:absolute;
      height: var(--noteH);
      border-radius: 12px;
      background: rgba(255,255,255,.92);
      box-shadow: 0 10px 24px rgba(0,0,0,.30);
      opacity:.98;
      z-index: 10;
      transition: filter .06s ease, transform .06s ease, opacity .12s ease, background .08s ease;
      will-change: transform, opacity, filter;
    }
    .note.chord{ background: rgba(120,220,255,.92); }

    .note.inWindow{
      background: rgba(120,220,255,.95);
      filter: brightness(1.12);
      box-shadow: 0 16px 32px rgba(0,0,0,.34), 0 0 18px rgba(120,220,255,.22);
    }
    .note.hit{
      background: rgba(255,255,255,.98);
      transform: translateY(14px) scale(0.98);
      opacity: 0;
    }
    .note.missed{
      background: rgba(255,255,255,.35);
      opacity: 0;
      transform: translateY(10px);
    }

    .centerUI{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      pointer-events:none;
      z-index: 30;
    }
    .judgeBox{
      transform: translateY(-30px);
      text-align:center;
      min-width: 240px;
    }
    .judgeText{
      font-size: 46px;
      font-weight: 950;
      letter-spacing: .8px;
      text-shadow: 0 16px 60px rgba(0,0,0,.72);
      opacity: 0;
      transform: translateY(10px) scale(.98);
      transition: opacity .12s ease, transform .12s ease;
      line-height: 1.02;
    }
    .judgeText.show{
      opacity: 1;
      transform: translateY(0) scale(1);
    }
    .comboText{
      margin-top: 8px;
      font-size: 18px;
      font-weight: 900;
      color: rgba(255,255,255,.90);
      text-shadow: 0 12px 34px rgba(0,0,0,.62);
      opacity: 0;
      transition: opacity .12s ease, transform .12s ease;
      transform: translateY(6px);
    }
    .comboText.show{
      opacity: 1;
      transform: translateY(0);
    }

    .countdown{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: 72px;
      font-weight: 950;
      letter-spacing: 1px;
      color: rgba(255,255,255,.92);
      text-shadow: 0 18px 80px rgba(0,0,0,.8);
      opacity: 0;
      transform: scale(.95);
      transition: opacity .12s ease, transform .12s ease;
      pointer-events:none;
      z-index: 32;
    }
    .countdown.show{ opacity: 1; transform: scale(1); }

    /* ✅ 하단 미니 HUD */
    .miniHUD{
      position:absolute;
      left:12px;
      right:12px;
      bottom: calc(10px + env(safe-area-inset-bottom));
      z-index: 25;
      display:flex;
      justify-content:space-between;
      gap:8px;
      pointer-events:none;
      height: var(--miniHUDH);
    }
    .miniHUD .pill{
      flex: 1 1 0;
      background: rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 999px;
      padding: 7px 10px;
      font-size: 12px;
      color: rgba(255,255,255,.75);
      backdrop-filter: blur(10px);
      display:flex;
      justify-content:space-between;
      gap:10px;
      align-items:center;
    }
    .mono{ font-variant-numeric: tabular-nums; font-feature-settings:"tnum"; }

    /* ✅ 터치패드: 히트박스처럼 빛나는 표현 */
    .touchLayer{
      position:absolute;
      left:0; right:0;
      bottom: calc(10px + env(safe-area-inset-bottom) + var(--miniHUDH) + 8px);
      padding: 0 12px;
      display:flex;
      gap: var(--laneGap);
      z-index: 20;
      touch-action: none;
      user-select:none;
      -webkit-user-select:none;
      -webkit-touch-callout:none;
    }
    .touchPad{
      flex: 1 1 0;
      height: var(--padH);
      border-radius: var(--padRadius);
      background: rgba(255,255,255,.05);
      border: 1px solid rgba(255,255,255,.12);
      box-shadow:
        inset 0 0 0 1px rgba(0,0,0,.18),
        inset 0 -80px 140px rgba(0,0,0,.18);
      position:relative;
      overflow:hidden;
    }

    /* ✅ “패드 전체가 히트박스” 느낌: 상단 히트존 글로우 */
    .touchPad::before{
      content:"";
      position:absolute;
      left:0; right:0;
      top:0;
      height: var(--hitGlowH);
      opacity: var(--hitGlowOpacity);
      background:
        radial-gradient(120% 120% at 50% 0%,
          rgba(120,220,255,.28),
          rgba(120,220,255,.16) 45%,
          rgba(120,220,255,.00) 75%),
        linear-gradient(to bottom,
          rgba(120,220,255,.18),
          rgba(120,220,255,.08) 55%,
          rgba(120,220,255,.00));
      pointer-events:none;
      transition: opacity .08s ease, filter .08s ease;
      filter: saturate(1.2) brightness(1.05);
      box-shadow:
    inset 0 1px 0 rgba(255,255,255,.10),
    inset 0 -1px 0 rgba(255,255,255,.10);  /* ✅ 선이 아니라 밴드 경계감 */
    }

    /* ✅ 입력중 더 강한 발광 */
    .touchPad.active{
      border-color: rgba(120,220,255,.45);
      background: rgba(120,220,255,.10);
      box-shadow:
        inset 0 0 0 1px rgba(120,220,255,.20),
        0 0 30px rgba(120,220,255,.18);
    }
    .touchPad.active::before{
      opacity: 1;
      filter: saturate(1.4) brightness(1.12);
    }

    /* ✅ 노트가 판정 윈도우에 들어오면 해당 패드가 “자동으로” 더 빛나게 (JS에서 pad.inWindow 토글) */
    .touchPad.inWindow::before{
      opacity: 1;
      filter: saturate(1.5) brightness(1.18);
    }

    .touchLabelRow{
      position:absolute;
      left:12px; right:12px;
      bottom: calc(10px + env(safe-area-inset-bottom) + var(--miniHUDH) + 8px + 10px);
      z-index: 21;
      display:flex;
      gap: var(--laneGap);
      pointer-events:none;
      opacity:.85;
    }
    .touchLabel{
      flex:1 1 0;
      text-align:center;
      font-weight:900;
      letter-spacing:.7px;
      color: rgba(255,255,255,.70);
      text-shadow: 0 10px 30px rgba(0,0,0,.60);
    }

    /* -----------------------------
       Result Modal
       ----------------------------- */
    .modal{
      position:absolute;
      inset:0;
      z-index: 60;
      display:none;
      align-items:center;
      justify-content:center;
      padding: 18px;
    }
    .modal.show{ display:flex; }
    .modal .backdrop{
      position:absolute; inset:0;
      background: rgba(0,0,0,.65);
      backdrop-filter: blur(6px);
    }
    .modal .panel{
      position:relative;
      width: min(680px, 92vw);
      border-radius: 16px;
      background: rgba(10,12,16,.86);
      border: 1px solid rgba(255,255,255,.14);
      box-shadow: 0 30px 120px rgba(0,0,0,.65);
      overflow:hidden;
    }
    .panelHeader{
      padding: 12px 14px;
      border-bottom: 1px solid rgba(255,255,255,.10);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
    }
    .tabs{ display:flex; gap: 8px; flex-wrap:wrap; }
    .tab{
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.25);
      font-size: 13px;
      color: rgba(255,255,255,.8);
      cursor:pointer;
      user-select:none;
      -webkit-user-select:none;
    }
    .tab.active{
      border-color: rgba(120,220,255,.45);
      background: rgba(120,220,255,.10);
      color: rgba(255,255,255,.92);
    }
    .panelBody{
      padding: 14px 14px 16px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    .block{
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      padding: 14px;
      background: rgba(0,0,0,.22);
    }
    .gradeBig{
      font-size: 72px;
      font-weight: 980;
      letter-spacing: 1px;
      margin: 0;
      line-height: .95;
      text-shadow: 0 20px 80px rgba(0,0,0,.8);
    }
    .scoreSmall{
      margin-top: 10px;
      font-size: 26px;
      font-weight: 900;
      color: rgba(255,255,255,.88);
    }
    .subInfo{
      margin-top: 8px;
      font-size: 14px;
      color: rgba(255,255,255,.78);
      line-height: 1.35;
    }
    .kvs{
      margin-top: 10px;
      display:flex;
      flex-direction:column;
      gap: 6px;
      color: rgba(255,255,255,.75);
      font-size: 13px;
    }
    .kvs div{
      display:flex;
      justify-content:space-between;
      gap: 10px;
      font-variant-numeric: tabular-nums;
    }
    .panelFooter{
      padding: 12px 14px 14px;
      border-top: 1px solid rgba(255,255,255,.10);
      display:flex;
      justify-content:flex-end;
      gap: 10px;
    }

    /* ✅ 디버그 오버레이(뻑나면 화면에 에러 띄움) */
    .debug{
      position:absolute;
      left:10px; right:10px;
      top: calc(10px + env(safe-area-inset-top));
      z-index: 100;
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(255, 80, 80, .14);
      border: 1px solid rgba(255, 120, 120, .30);
      backdrop-filter: blur(8px);
      display:none;
      white-space: pre-wrap;
      font-size: 12px;
      color: rgba(255,255,255,.92);
    }
    .debug.show{ display:block; }
  </style>
</head>

<body>
  <div class="app" id="app">
    <div class="bg" id="bg"></div>

    <div class="hud">
      <div class="left">
        <div class="badge"><strong>모바일</strong> 4패드</div>
        <select id="songSelect"></select>
      </div>
      <div class="right">
        <button id="startBtn" class="btnPrimary">시작</button>
        <button id="stopBtn" class="btnDanger">정지</button>
      </div>
    </div>

    <div class="stage">
      <div class="laneBoard" id="laneBoard">
        <div class="lanes" id="lanes">
          <div class="lane"></div>
          <div class="lane"></div>
          <div class="lane"></div>
          <div class="lane"></div>
        </div>

        <div class="centerUI">
          <div class="judgeBox">
            <div class="judgeText" id="judgeText">Perfect</div>
            <div class="comboText" id="comboText">콤보 0</div>
          </div>
        </div>

        <div class="countdown" id="countdown">3</div>

        <div class="touchLabelRow">
          <div class="touchLabel">D</div>
          <div class="touchLabel">F</div>
          <div class="touchLabel">J</div>
          <div class="touchLabel">K</div>
        </div>

        <div class="touchLayer" id="touchLayer">
          <div class="touchPad" data-lane="0"></div>
          <div class="touchPad" data-lane="1"></div>
          <div class="touchPad" data-lane="2"></div>
          <div class="touchPad" data-lane="3"></div>
        </div>

        <div class="miniHUD">
          <div class="pill mono"><span>점수</span><strong id="scoreText">0</strong></div>
          <div class="pill mono"><span>맥스 콤보</span><strong id="maxComboText">0</strong></div>
          <div class="pill mono"><span>정확도</span><strong id="accText">—</strong></div>
        </div>

        <audio id="audio" preload="auto" crossorigin="anonymous"></audio>
      </div>
    </div>

    <div class="modal" id="modal">
      <div class="backdrop"></div>
      <div class="panel">
        <div class="panelHeader">
          <div class="tabs">
            <div class="tab active" data-tab="result">결과</div>
            <div class="tab" data-tab="detail">상세</div>
          </div>
          <button id="closeModalBtn">닫기</button>
        </div>
        <div class="panelBody" id="modalBody"></div>
        <div class="panelFooter">
          <button id="restartBtn" class="btnPrimary">같은 곡 다시</button>
          <button id="backToMenuBtn">닫기</button>
        </div>
      </div>
    </div>

    <div class="debug" id="debug"></div>
  </div>

<script>
(async() => {
  // -----------------------------
  // Debug overlay: "뻑남" 원인을 화면에 보여주기
  // -----------------------------
  const debugEl = document.getElementById("debug");
  function showDebug(msg){
    if(!debugEl) return;
    debugEl.textContent = msg;
    debugEl.classList.add("show");
  }
  window.addEventListener("error", (e) => {
    showDebug(`JS ERROR:\n${e.message}\n${e.filename}:${e.lineno}:${e.colno}`);
  });
  window.addEventListener("unhandledrejection", (e) => {
    const m = (e.reason && (e.reason.stack || e.reason.message)) ? (e.reason.stack || e.reason.message) : String(e.reason);
    showDebug(`PROMISE ERROR:\n${m}`);
  });

  // -----------------------------
  // Songs
  // -----------------------------
  const SONGS = [
    { id:"badguys",    name:"BadGuys",    audio:"assets/audio/BadGuys.mp3",    bg:"assets/bg/bg_BadGuys.png",    bpm:135, offsetMs:0, scrollMs:1700 },
    { id:"missingyou", name:"MissingYou", audio:"assets/audio/MissingYou.mp3", bg:"assets/bg/bg_MissingYou.png", bpm:120, offsetMs:0, scrollMs:1700 },
    { id:"restnpeace", name:"RestNPeace", audio:"assets/audio/RestNPeace.mp3", bg:"assets/bg/bg_RestNPeace.png", bpm:120, offsetMs:0, scrollMs:1700 }
  ];

  // -----------------------------
  // DOM
  // -----------------------------
  const bgEl = document.getElementById("bg");
  const songSelect = document.getElementById("songSelect");
  const startBtn = document.getElementById("startBtn");
  const stopBtn = document.getElementById("stopBtn");

  const laneBoard = document.getElementById("laneBoard");
  const lanesEl = document.getElementById("lanes");
  const laneEls = Array.from(document.querySelectorAll(".lane"));

  const judgeTextEl = document.getElementById("judgeText");
  const comboTextEl = document.getElementById("comboText");
  const scoreTextEl = document.getElementById("scoreText");
  const maxComboTextEl = document.getElementById("maxComboText");
  const accTextEl = document.getElementById("accText");

  const countdownEl = document.getElementById("countdown");
  const audioEl = document.getElementById("audio");

  const touchLayer = document.getElementById("touchLayer");
  const touchPads = touchLayer ? Array.from(touchLayer.querySelectorAll(".touchPad")) : [];

  const modal = document.getElementById("modal");
  const modalBody = document.getElementById("modalBody");
  const closeModalBtn = document.getElementById("closeModalBtn");
  const restartBtn = document.getElementById("restartBtn");
  const backToMenuBtn = document.getElementById("backToMenuBtn");
  const tabEls = Array.from(document.querySelectorAll(".tab"));

  if(!laneBoard || !lanesEl || !audioEl || !touchLayer){
    showDebug("DOM이 일부 없습니다. mobile.html 구조가 깨졌는지 확인해줘요.");
    return;
  }

  // -----------------------------
  // State
  // -----------------------------
  let currentSong = SONGS[0];
  let chart = null;
  window.chart = null;

  let running = false;
  let rafId = 0;
  let preRolling = false;
  let goPerf = 0;

  // ✅ “시작하자마자 멈춤” 방지 플래그
  let audioStarted = false;
  let audioStartPerf = 0;

  // ✅ 패드 히트존(판정 기준 Y): 패드 상단 ~ hitGlowH 영역 중간
  let hitYpx = 520;

  const notePool = [];
  const activeNotesDOM = new Map();

  const stats = {
    score: 0,
    combo: 0,
    maxCombo: 0,
    perfect: 0,
    great: 0,
    good: 0,
    miss: 0,
    total: 0,
    hit: 0
  };

  const JUDGE = [
    { name: "Perfect", win: 45,  color: "var(--accent)", score: 1000 },
    { name: "Great",   win: 85,  color: "var(--good)",  score: 700  },
    { name: "Good",    win: 125, color: "var(--warn)",  score: 400  },
    { name: "Miss",    win: 170, color: "var(--bad)",   score: 0    }
  ];

  const hitLock = new Array(4).fill(0);
  const HIT_LOCK_MS = 45;
  let countdownTimer = 0;

  // -----------------------------
  // Helpers
  // -----------------------------
  function setBackground(url){
    bgEl.style.backgroundImage = `url("${url}")`;
    bgEl.style.backgroundSize = "cover";
    bgEl.style.backgroundPosition = "center";
  }
  function fmt(n){ return (n|0).toString().replace(/\B(?=(\d{3})+(?!\d))/g, ","); }

  function resetStats(){
    stats.score = 0;
    stats.combo = 0;
    stats.maxCombo = 0;
    stats.perfect = 0;
    stats.great = 0;
    stats.good = 0;
    stats.miss = 0;
    stats.total = 0;
    stats.hit = 0;
    updateHUD();
  }

  function updateHUD(){
    scoreTextEl.textContent = fmt(stats.score);
    maxComboTextEl.textContent = String(stats.maxCombo);
    const acc = stats.total > 0 ? (stats.hit / stats.total) : 0;
    accTextEl.textContent = stats.total ? `${(acc*100).toFixed(1)}%` : "—";
  }

  function flashJudge(name, color){
    judgeTextEl.textContent = name;
    judgeTextEl.style.color = color;
    judgeTextEl.classList.add("show");
    setTimeout(() => judgeTextEl.classList.remove("show"), 160);

    comboTextEl.textContent = `콤보 ${stats.combo}`;
    if(stats.combo > 0){
      comboTextEl.classList.add("show");
      setTimeout(() => comboTextEl.classList.remove("show"), 260);
    }
  }

  function clearNotesDOM(){
    for(const [, el] of activeNotesDOM){
      el.remove();
      notePool.push(el);
    }
    activeNotesDOM.clear();
  }

  function getNoteEl(){
    const el = notePool.pop() || document.createElement("div");
    el.className = "note";
    return el;
  }

  function nowMs(){
    if(!running) return 0;
    if(preRolling) return (performance.now() - goPerf);
    return (audioEl.currentTime * 1000);
  }

  function laneGeom(){
    const style = getComputedStyle(lanesEl);
    const padL = parseFloat(style.paddingLeft) || 0;
    const padR = parseFloat(style.paddingRight) || 0;
    const gap = parseFloat(style.gap) || 0;

    const boardW = laneBoard.clientWidth;
    const innerW = boardW - padL - padR;
    const w = (innerW - gap*3) / 4;
    return { padL, gap, w };
  }

  function laneX(laneIndex){
    const g = laneGeom();
    return g.padL + laneIndex * (g.w + g.gap);
  }

  function setLaneActive(lane, on){
    const le = laneEls[lane];
    if(le) le.classList.toggle("lit", !!on);
    const pad = touchPads[lane];
    if(pad) pad.classList.toggle("active", !!on);
  }

  // -----------------------------
  // ✅ Hitbox: "패드 상단 히트존"을 기준으로 노트가 내려오게
  // -----------------------------
  function updateHitbox(){
    // 레이아웃이 아직 0일 수 있어서 방어
    const top = touchLayer.offsetTop;
    const h = touchLayer.clientHeight || parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--padH")) || 150;

    // 히트존(발광) 높이의 "중앙"을 판정 기준으로 잡기
    const glowH = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--hitGlowH")) || 90;
    const hitCenterFromTop = Math.min(glowH * 0.5, h * 0.5);

    if(top && top > 20){
      hitYpx = top + hitCenterFromTop;
    }
  }

  function chartTimeToScreenY(noteTms, currentTms){
    const dt = noteTms - currentTms;
    const progress = 1 - (dt / chart.scrollMs);
    const yStart = -60;
    const yEnd = hitYpx;
    return yStart + (yEnd - yStart) * progress;
  }

  // -----------------------------
  // Vibration
  // -----------------------------
  let lastVibeAt = 0;
  function vibe(pattern){
    if(!navigator.vibrate) return;
    const now = performance.now();
    if(now - lastVibeAt < 35) return;
    lastVibeAt = now;
    try{ navigator.vibrate(pattern); }catch(e){}
  }
  function vibeTap(){ vibe(8); }
  function vibeJudge(judgeName){
    if(judgeName === "Perfect") vibe([10]);
    else if(judgeName === "Great") vibe([8]);
    else if(judgeName === "Good") vibe([6]);
    else vibe([12, 35, 12]);
  }

  // -----------------------------
  // Countdown
  // -----------------------------
  function showCountdown(show, text=""){
    countdownEl.classList.toggle("show", !!show);
    if(show) countdownEl.textContent = text;
  }

  async function runCountdown(seconds=3){
    clearTimeout(countdownTimer);
    for(let s=seconds; s>=1; s--){
      showCountdown(true, String(s));
      await new Promise(r => countdownTimer=setTimeout(r, 950));
    }
    showCountdown(true, "GO!");
    await new Promise(r => countdownTimer=setTimeout(r, 300));
    showCountdown(false);
  }

  // -----------------------------
  // Modal
  // -----------------------------
  function openModal(tab="result"){
    modal.classList.add("show");
    setActiveTab(tab);
    renderModal(tab);
  }
  function closeModal(){ modal.classList.remove("show"); }
  function setActiveTab(tab){
    tabEls.forEach(t => t.classList.toggle("active", t.dataset.tab === tab));
  }
  function gradeFromAcc(acc){
    if(acc >= 0.98) return "S";
    if(acc >= 0.95) return "A";
    if(acc >= 0.90) return "B";
    if(acc >= 0.80) return "C";
    return "D";
  }
  function renderModal(tab){
    const acc = stats.total ? (stats.hit / stats.total) : 0;
    const grade = gradeFromAcc(acc);
    const score = stats.score;

    if(tab === "result"){
      modalBody.innerHTML = `
        <div class="block">
          <p class="gradeBig">${grade}</p>
          <div class="subInfo">
            정확도 <strong>${(acc*100).toFixed(1)}%</strong><br>
            Max Combo <strong>${stats.maxCombo}</strong>
          </div>
          <div class="scoreSmall mono">${fmt(score)}</div>
          <div class="kvs">
            <div><span>노트 수</span><strong class="mono">${stats.total}</strong></div>
            <div><span>곡</span><strong>${currentSong.name}</strong></div>
            <div><span>설정</span><strong class="mono">BPM ${chart.bpm} · OFF ${chart.offsetMs} · SCR ${chart.scrollMs}</strong></div>
          </div>
        </div>
        <div class="block">
          <div class="kvs">
            <div><span>Perfect</span><strong class="mono">${stats.perfect}</strong></div>
            <div><span>Great</span><strong class="mono">${stats.great}</strong></div>
            <div><span>Good</span><strong class="mono">${stats.good}</strong></div>
            <div><span>Miss</span><strong class="mono">${stats.miss}</strong></div>
          </div>
        </div>
      `;
    }else{
      modalBody.innerHTML = `
        <div class="block" style="grid-column:1 / -1;">
          <div class="kvs">
            <div><span>점수</span><strong>Perfect 1000 / Great 700 / Good 400</strong></div>
            <div><span>콤보</span><strong>combo × 0.4 (최대 1.4배)</strong></div>
            <div><span>모바일</span><strong>패드 상단 히트존 발광</strong></div>
          </div>
        </div>
      `;
    }
  }

  // -----------------------------
  // Chart load
  // -----------------------------
  function defaultChartFor(song){
    return {
      version: 1,
      songId: song.id,
      audio: song.audio,
      offsetMs: song.offsetMs,
      scrollMs: song.scrollMs,
      bpm: song.bpm,
      notes: []
    };
  }

  function normalizeChart(obj, song){
    const safe = defaultChartFor(song);
    safe.version = obj.version ?? safe.version;
    safe.songId = song.id;
    safe.audio = song.audio;
    safe.offsetMs = Number(obj.offsetMs ?? song.offsetMs) || 0;
    safe.scrollMs = Number(obj.scrollMs ?? song.scrollMs) || 1700;
    safe.bpm = Number(obj.bpm ?? song.bpm) || song.bpm;

    safe.notes = Array.isArray(obj.notes) ? obj.notes
      .filter(n => Number.isFinite(n.t) && Number.isFinite(n.lane))
      .map(n => ({
        t: Math.max(0, Math.round(n.t)),
        lane: Math.max(0, Math.min(3, Math.round(n.lane)))
      }))
      .sort((a,b)=>a.t-b.t || a.lane-b.lane)
      : [];

    safe.notes.forEach(n => { delete n._hit; });
    return safe;
  }

  async function loadChartFromFile(song){
    const url = new URL(`charts/${song.id}.json`, window.location.href);
    const res = await fetch(url, { cache: "no-store" });
    if(!res.ok) throw new Error(`chart fetch failed: ${res.status} ${res.statusText} / ${url}`);
    const obj = await res.json();
    chart = normalizeChart(obj, song);
    window.chart = chart;
  }

  function applySongToUI(){
    setBackground(currentSong.bg);
    audioEl.src = currentSong.audio;
    audioEl.load();
  }

  // -----------------------------
  // Toast
  // -----------------------------
  let toastTimer = 0;
  function toast(msg){
    clearTimeout(toastTimer);
    judgeTextEl.textContent = msg;
    judgeTextEl.style.color = "rgba(255,255,255,.92)";
    judgeTextEl.classList.add("show");
    toastTimer = setTimeout(()=>judgeTextEl.classList.remove("show"), 900);
  }

  // -----------------------------
  // Gameplay
  // -----------------------------
  async function startGame(){
    if(running) return;
    if(!chart) chart = defaultChartFor(currentSong);
    if(!chart.notes || chart.notes.length === 0){
      toast("채보가 비어있어요. charts/*.json 확인!");
      return;
    }

    closeModal();
    resetStats();
    clearNotesDOM();

    audioEl.pause();
    audioEl.currentTime = 0;

    audioStarted = false;
    audioStartPerf = 0;

    // 프리롤
    running = true;
    preRolling = true;

    const COUNTDOWN_TOTAL_MS = 3150;
    goPerf = performance.now() + COUNTDOWN_TOTAL_MS;

    updateHitbox();
    rafId = requestAnimationFrame(loop);

    await runCountdown(3);
    preRolling = false;

    try{
      // ✅ 첫 스타트 안정화: 로드 + 아주 짧은 대기 + play
      audioEl.load();
      await new Promise(r=>setTimeout(r, 60));
      await audioEl.play();

      audioStarted = true;
      audioStartPerf = performance.now();

    }catch(err){
      running = false;
      toast("오디오 재생 실패: 자동재생 제한일 수 있어요.");
      return;
    }

    rafId = requestAnimationFrame(loop);
  }

  function stopGame(showResult=false){
    if(!running && !showResult) return;
    running = false;
    cancelAnimationFrame(rafId);
    rafId = 0;

    audioEl.pause();
    for(let i=0;i<4;i++) setLaneActive(i,false);

    if(showResult) openModal("result");
  }

  function loop(){
    if(!running) return;

    updateHitbox();

    const tms = nowMs() - chart.offsetMs;
    const g = laneGeom();
    const laneW = g.w;

    const appearFrom = tms - 200;
    const appearTo = tms + chart.scrollMs + 420;

    // ✅ 이번 프레임에 패드 자동 발광(inWindow) 리셋
    touchPads.forEach(p => p.classList.remove("inWindow"));

    for(let i=0; i<chart.notes.length; i++){
      const n = chart.notes[i];
      if(n.t < appearFrom) continue;
      if(n.t > appearTo) break;

      let el = activeNotesDOM.get(i);
      if(!el){
        el = getNoteEl();
        activeNotesDOM.set(i, el);
        laneBoard.appendChild(el);
      }

      const y = chartTimeToScreenY(n.t, tms);
      const x = laneX(n.lane);

      el.style.left = `${x + 8}px`;
      el.style.width = `${laneW - 16}px`;
      el.style.height = `${parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--noteH"))}px`;
      // ✅ 노트 중앙이 히트 기준에 오도록
      const noteH = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--noteH")) || 34;
      el.style.top = `${y - (noteH/2)}px`;
      el.style.display = "";

      const dt = n.t - tms;

      const inWin = Math.abs(dt) <= 140 && !n._hit;
      el.classList.toggle("inWindow", inWin);

      // ✅ 노트가 판정 윈도우에 들어오면 해당 패드도 자동 발광
      if(inWin){
        const pad = touchPads[n.lane];
        if(pad) pad.classList.add("inWindow");
      }

      const prev = chart.notes[i-1];
      const next = chart.notes[i+1];
      const isChord = (prev && prev.t === n.t) || (next && next.t === n.t);
      el.classList.toggle("chord", !!isChord);
    }

    const missWin = JUDGE[JUDGE.length-1].win;

    for(const [i, el] of Array.from(activeNotesDOM.entries())){
      const n = chart.notes[i];
      if(tms - n.t > missWin){
        if(!n._hit){
          n._hit = true;
          stats.total++;
          stats.miss++;
          stats.combo = 0;
          flashJudge("Miss", "var(--bad)");
          vibeJudge("Miss");
          updateHUD();
        }
        el.classList.add("missed");
        activeNotesDOM.delete(i);
        setTimeout(() => {
          el.remove();
          notePool.push(el);
        }, 140);
      }
    }

    // ✅ “시작하자마자 멈춤” 방지: 오디오가 실제로 재생된 뒤 + 0.6초 이후부터만 종료판정
    // ✅ 모바일 오디오 ended/duration 튐으로 인한 "시작 즉시 종료" 방지
// ✅ 마지막 노트 이후 Nms 지나면 종료 (오디오가 잠깐 멈춰도 게임은 유지됨)
const lastNoteT = chart?.notes?.length ? chart.notes[chart.notes.length - 1].t : 0;
if(tms > lastNoteT + 3500){   // 3.5초 여유
  stopGame(true);
  return;
}

    rafId = requestAnimationFrame(loop);
  }

  function applyJudgeResult(judge){
    stats.total++;
    if(judge.name !== "Miss"){
      stats.hit++;
      stats.combo++;
      stats.maxCombo = Math.max(stats.maxCombo, stats.combo);

      const mult = 1 + Math.min(0.4, stats.combo * 0.004);
      stats.score += Math.round(judge.score * mult);

      if(judge.name === "Perfect") stats.perfect++;
      else if(judge.name === "Great") stats.great++;
      else if(judge.name === "Good") stats.good++;
    }else{
      stats.miss++;
      stats.combo = 0;
    }

    flashJudge(judge.name, judge.color);
    vibeJudge(judge.name);
    updateHUD();
  }

  function judgeLanePress(lane){
    if(!running || !chart?.notes?.length) return;

    const tms = nowMs() - chart.offsetMs;

    if(Math.abs(tms - hitLock[lane]) < HIT_LOCK_MS) return;
    hitLock[lane] = tms;

    const missWin = JUDGE[JUDGE.length-1].win;
    const minT = tms - missWin;
    const maxT = tms + missWin;

    let bestIdx = -1;
    let bestAbs = Infinity;

    let lo = 0, hi = chart.notes.length-1, start = 0;
    while(lo <= hi){
      const mid = (lo + hi) >> 1;
      if(chart.notes[mid].t < minT) lo = mid + 1;
      else { start = mid; hi = mid - 1; }
    }

    for(let i = start; i < chart.notes.length; i++){
      const n = chart.notes[i];
      if(n.t > maxT) break;
      if(n._hit) continue;
      if(n.lane !== lane) continue;

      const d = Math.abs(n.t - tms);
      if(d < bestAbs){
        bestAbs = d;
        bestIdx = i;
      }
    }

    if(bestIdx === -1){
      applyJudgeResult(JUDGE[JUDGE.length-1]);
      return;
    }

    const n = chart.notes[bestIdx];
    const d = Math.abs(n.t - tms);

    let judge = JUDGE[JUDGE.length-1];
    for(const j of JUDGE){
      if(d <= j.win){ judge = j; break; }
    }

    n._hit = true;
    applyJudgeResult(judge);

    const el = activeNotesDOM.get(bestIdx);
    if(el){
      el.classList.add("hit");
      el.classList.remove("inWindow");
      activeNotesDOM.delete(bestIdx);
      setTimeout(() => {
        el.remove();
        notePool.push(el);
      }, 140);
    }
  }

  // -----------------------------
  // Audio unlock
  // -----------------------------
  function unlockAudioOnce(){
    if(unlockAudioOnce._done) return;
    unlockAudioOnce._done = true;

    try{
      const wasMuted = audioEl.muted;
      audioEl.muted = true;
      const p = audioEl.play();
      if(p && p.then){
        p.then(()=>{
          audioEl.pause();
          audioEl.currentTime = 0;
          audioEl.muted = wasMuted;
        }).catch(()=>{
          audioEl.muted = wasMuted;
        });
      }else{
        audioEl.muted = wasMuted;
      }
    }catch(e){}
  }

  // -----------------------------
  // Touch wiring
  // -----------------------------
  touchPads.forEach(pad => {
    const lane = Number(pad.dataset.lane);

    pad.addEventListener("pointerdown", (e) => {
      e.preventDefault();
      pad.setPointerCapture(e.pointerId);

      unlockAudioOnce();
      vibeTap();
      setLaneActive(lane, true);
      judgeLanePress(lane);
    }, { passive:false });

    pad.addEventListener("pointerup", (e) => {
      e.preventDefault();
      setLaneActive(lane, false);
    }, { passive:false });

    pad.addEventListener("pointercancel", () => {
      setLaneActive(lane, false);
    });
  });

  // -----------------------------
  // Wiring
  // -----------------------------
  function initSongSelect(){
    songSelect.innerHTML = "";
    for(const s of SONGS){
      const opt = document.createElement("option");
      opt.value = s.id;
      opt.textContent = s.name;
      songSelect.appendChild(opt);
    }
    songSelect.value = currentSong.id;
  }

  async function setSongById(id){
    const s = SONGS.find(x => x.id === id) || SONGS[0];
    currentSong = s;

    applySongToUI();

    try{
      await loadChartFromFile(currentSong);
      toast(`채보 로드: ${currentSong.name}`);
    }catch(e){
      console.error(e);
      chart = defaultChartFor(currentSong);
      toast("채보 파일을 찾지 못했어요 (charts 폴더/파일명 확인)");
    }

    // 레이아웃 안정화 후 hitbox 계산
    requestAnimationFrame(()=> {
      updateHitbox();
    });
  }

  songSelect.addEventListener("change", async () => {
    stopGame(false);
    await setSongById(songSelect.value);
  });

  startBtn.addEventListener("click", () => startGame());
  stopBtn.addEventListener("click", () => stopGame(false));

  closeModalBtn.addEventListener("click", closeModal);
  backToMenuBtn.addEventListener("click", closeModal);
  restartBtn.addEventListener("click", () => {
    closeModal();
    startGame();
  });
  tabEls.forEach(t => {
    t.addEventListener("click", () => {
      setActiveTab(t.dataset.tab);
      renderModal(t.dataset.tab);
    });
  });

  audioEl.addEventListener("ended", () => {
  // ✅ 모바일에서 ended가 순간적으로 튀는 기기/브라우저가 있어서 무시
  // 종료는 loop에서 "마지막 노트 시간" 기준으로만 처리
});


  // 초기화
  initSongSelect();
  await setSongById(currentSong.id);
  showCountdown(false);

  window.addEventListener("resize", () => {
    updateHitbox();
  });

})();
</script>
</body>
</html>

