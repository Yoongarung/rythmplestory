<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>4키 리듬게임</title>
  <style>
    :root{
      --w: 920px;
      --h: 620px;
      --laneW: 110px;
      --laneGap: 14px;
      --hitY: 490px;
      --noteH: 18px;

      --glass: rgba(10,12,16,.55);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.65);

      --accent: rgba(120,220,255,.95);
      --good: rgba(140, 255, 180, .95);
      --warn: rgba(255, 216, 120, .95);
      --bad: rgba(255, 120, 120, .95);

      --shadow: 0 20px 80px rgba(0,0,0,.55);

      --hitBandH: 34px;

      /* ✅ Lane glow strength */
      --laneGlowOpacity: 1;
      --laneGlowBoost: 1.95;
    }

    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial;
      color: var(--text);
      background: #0b0f14;
      display:flex;
      align-items:center;
      justify-content:center;
      min-height:100vh;
    }

    .app{
      width: min(var(--w), calc(100vw - 22px));
      box-shadow: var(--shadow);
      border-radius: 18px;
      overflow:hidden;
      position:relative;
      background:#0b0f14;
      border: 1px solid rgba(255,255,255,.08);
    }

    .bg{
      position:absolute; inset:0;
      background:#0b0f14 center/cover no-repeat;
      transform: scale(1.02);
      filter: saturate(1.05) contrast(1.05);
    }
    .bg::after{
      content:"";
      position:absolute; inset:0;
      background: radial-gradient(90% 70% at 50% 30%, rgba(0,0,0,.15), rgba(0,0,0,.62) 55%, rgba(0,0,0,.86));
    }

    .hud{
      position:relative;
      z-index:2;
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 14px 16px;
      background: linear-gradient(to bottom, rgba(0,0,0,.55), rgba(0,0,0,.05));
      border-bottom: 1px solid rgba(255,255,255,.08);
    }

    .left, .right{ display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    .badge{
      background: rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 999px;
      padding: 7px 10px;
      font-size: 12px;
      color: var(--muted);
      display:flex; align-items:center; gap:8px;
      backdrop-filter: blur(10px);
      user-select:none;
    }
    .badge strong{ color: var(--text); font-weight:700; }

    select, button, input[type="number"]{
      background: rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.16);
      color: var(--text);
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 13px;
      outline:none;
      backdrop-filter: blur(10px);
    }
    select{ padding-right: 26px; }
    button{
      cursor:pointer;
      transition: transform .06s ease, background .2s ease, border-color .2s ease;
      user-select:none;
    }
    button:hover{ border-color: rgba(255,255,255,.28); }
    button:active{ transform: translateY(1px); }

    .btnPrimary{
      background: rgba(120,220,255,.16);
      border-color: rgba(120,220,255,.40);
    }
    .btnDanger{
      background: rgba(255,120,120,.12);
      border-color: rgba(255,120,120,.35);
    }

    .stage{
      position:relative;
      z-index:2;
      height: var(--h);
      padding: 18px 16px 18px;
    }

    .gameWrap{
      width: 100%;
      height: 100%;
      display:flex;
      align-items:stretch;
      justify-content:center;
      gap: 14px;
      position:relative;
    }

    .laneBoard{
      width: min(520px, 100%);
      height: 100%;
      position:relative;
      border-radius: 16px;
      background: rgba(0,0,0,.25);
      border: 1px solid rgba(255,255,255,.12);
      backdrop-filter: blur(10px);
      overflow:hidden;
      flex: 0 0 min(520px, 100%);
    }

    .lanes{
      position:absolute; inset: 0;
      display:flex;
      align-items:flex-start;
      justify-content:center;
      gap: var(--laneGap);
      padding-top: 20px;
    }

    .lane{
      width: var(--laneW);
      height: 100%;
      position:relative;
      border-left: 1px solid rgba(255,255,255,.08);
      border-right: 1px solid rgba(255,255,255,.08);
      background: linear-gradient(to bottom, rgba(255,255,255,.04), rgba(255,255,255,.02));
      overflow:hidden;
    }
    .lane:first-child{ border-left-color: transparent; }
    .lane:last-child{ border-right-color: transparent; }

    .lane::after{
      content:"";
      position:absolute;
      inset:-10px;
      opacity:0;
      pointer-events:none;
      background:
        radial-gradient(120% 92% at 50% 78%,
          rgba(120,220,255,.56),
          rgba(120,220,255,.30) 46%,
          transparent 74%),
        linear-gradient(to bottom,
          rgba(120,220,255,.34),
          rgba(120,220,255,.14) 40%,
          transparent 76%);
      filter: saturate(1.45) brightness(1.14);
      transition: opacity .06s ease;
    }
    .lane.lit::after{
      opacity: calc(.70 * var(--laneGlowOpacity) * var(--laneGlowBoost));
    }
    .lane.lit{
      box-shadow:
        inset 0 0 0 1px rgba(120,220,255,.18),
        inset 0 -140px 220px rgba(120,220,255,.18),
        0 0 26px rgba(120,220,255,.14);
    }

    .hitBand{
      position:absolute;
      left:0; right:0;
      top: calc(var(--hitY) - (var(--hitBandH) / 2));
      height: var(--hitBandH);
      background: linear-gradient(to bottom,
        rgba(120,220,255,.00),
        rgba(120,220,255,.12),
        rgba(120,220,255,.00)
      );
      border-top: 1px solid rgba(255,255,255,.12);
      border-bottom: 1px solid rgba(255,255,255,.10);
      pointer-events:none;
      z-index: 2;
    }

    .hitLine{
      position:absolute;
      left: 0; right: 0;
      top: var(--hitY);
      height: 3px;
      background: rgba(255,255,255,.24);
      box-shadow:
        0 0 0 1px rgba(0,0,0,.3),
        0 0 30px rgba(120,220,255,.35);
      z-index: 3;
    }
    .hitLine::before{
      content:"";
      position:absolute;
      left: 8%;
      right: 8%;
      top: -16px;
      height: 32px;
      border-radius: 999px;
      background: radial-gradient(closest-side, rgba(120,220,255,.22), transparent 70%);
      pointer-events:none;
    }

    .keys{
      position:absolute;
      left: 0; right: 0;
      bottom: 14px;
      display:flex;
      justify-content:center;
      gap: var(--laneGap);
      pointer-events:none;
      z-index: 6;
    }
    .key{
      width: var(--laneW);
      height: 44px;
      border-radius: 12px;
      background: rgba(0,0,0,.36);
      border: 1px solid rgba(255,255,255,.14);
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight: 900;
      letter-spacing:.8px;
      color: rgba(255,255,255,.88);
      text-shadow: 0 4px 12px rgba(0,0,0,.55);
      position:relative;
    }
    .key.active{
      border-color: rgba(120,220,255,.65);
      box-shadow: 0 0 22px rgba(120,220,255,.28);
      background: rgba(120,220,255,.12);
    }

    .note{
      position:absolute;
      height: var(--noteH);
      border-radius: 10px;
      background: rgba(255,255,255,.90);
      box-shadow: 0 10px 24px rgba(0,0,0,.30);
      opacity:.97;
      z-index: 5;

      transition: filter .06s ease, transform .06s ease, opacity .12s ease, background .08s ease;
      will-change: transform, opacity, filter;
    }
    .note.chord{ background: rgba(120,220,255,.92); }

    .note.inWindow{
      background: rgba(120,220,255,.95);
      filter: brightness(1.12);
      box-shadow: 0 16px 32px rgba(0,0,0,.34), 0 0 18px rgba(120,220,255,.22);
    }

    .note.hit{
      background: rgba(255,255,255,.98);
      box-shadow: 0 18px 36px rgba(0,0,0,.38), 0 0 26px rgba(140,255,180,.22);
      transform: translateY(14px) scale(0.98);
      opacity: 0;
    }

    .note.missed{
      background: rgba(255,255,255,.35);
      filter: blur(.2px) brightness(.85);
      opacity: 0;
      transform: translateY(10px);
    }
    .note.hit.pf{ box-shadow: 0 0 28px rgba(120,220,255,.30); }
    .note.hit.gr{ box-shadow: 0 0 28px rgba(140,255,180,.26); }
    .note.hit.gd{ box-shadow: 0 0 28px rgba(255,216,120,.26); }

    .centerUI{
      position:absolute;
      inset: 0;
      display:flex;
      align-items:center;
      justify-content:center;
      pointer-events:none;
      z-index: 10;
    }
    .judgeBox{
      transform: translateY(-28px);
      text-align:center;
      min-width: 260px;
    }
    .judgeText{
      font-size: 54px;
      font-weight: 950;
      letter-spacing: .8px;
      text-shadow: 0 16px 60px rgba(0,0,0,.72);
      opacity: 0;
      transform: translateY(10px) scale(.98);
      transition: opacity .12s ease, transform .12s ease;
      line-height: 1.02;
    }
    .judgeText.show{
      opacity: 1;
      transform: translateY(0) scale(1);
    }
    .comboText{
      margin-top: 8px;
      font-size: 22px;
      font-weight: 900;
      color: rgba(255,255,255,.90);
      text-shadow: 0 12px 34px rgba(0,0,0,.62);
      opacity: .0;
      transition: opacity .12s ease, transform .12s ease;
      transform: translateY(6px);
    }
    .comboText.show{
      opacity: 1;
      transform: translateY(0);
    }

    .countdown{
      position:absolute;
      inset: 0;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: 76px;
      font-weight: 950;
      letter-spacing: 1px;
      color: rgba(255,255,255,.92);
      text-shadow: 0 18px 80px rgba(0,0,0,.8);
      opacity: 0;
      transform: scale(.95);
      transition: opacity .12s ease, transform .12s ease;
      pointer-events:none;
      z-index: 12;
    }
    .countdown.show{
      opacity: 1;
      transform: scale(1);
    }

    .sidePanel{
      position:relative;
      z-index: 3;
      width: 300px;
      display:flex;
      flex-direction:column;
      gap: 10px;
      align-self: flex-start;
    }
    .card{
      background: var(--glass);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 14px;
      padding: 12px 12px;
      backdrop-filter: blur(10px);
    }
    .row{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap: 10px;
      font-size: 13px;
      color: var(--muted);
      line-height: 1.25;
      margin: 4px 0;
    }
    .row strong{
      color: var(--text);
      font-weight: 900;
    }
    .mono{ font-variant-numeric: tabular-nums; font-feature-settings:"tnum"; }

    .footerTools{
      position:relative;
      z-index:2;
      padding: 14px 16px 16px;
      border-top: 1px solid rgba(255,255,255,.08);
      background: linear-gradient(to top, rgba(0,0,0,.55), rgba(0,0,0,.18));
      display:grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }
    textarea{
      width: 100%;
      min-height: 140px;
      resize: vertical;
      background: rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.16);
      color: rgba(255,255,255,.92);
      border-radius: 12px;
      padding: 10px 10px;
      font-size: 12px;
      line-height: 1.35;
      outline:none;
      backdrop-filter: blur(10px);
    }
    .toolRow{
      display:flex;
      gap: 10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
    }
    .toolRow .group{
      display:flex;
      gap: 10px;
      flex-wrap:wrap;
      align-items:center;
    }
    .hint{
      font-size:12px;
      color: rgba(255,255,255,.65);
    }

    .modal{
      position:absolute;
      inset: 0;
      z-index: 30;
      display:none;
      align-items:center;
      justify-content:center;
      padding: 18px;
    }
    .modal.show{ display:flex; }
    .modal .backdrop{
      position:absolute; inset:0;
      background: rgba(0,0,0,.65);
      backdrop-filter: blur(6px);
    }
    .modal .panel{
      position:relative;
      width: min(680px, 100%);
      border-radius: 16px;
      background: rgba(10,12,16,.84);
      border: 1px solid rgba(255,255,255,.14);
      box-shadow: 0 30px 120px rgba(0,0,0,.65);
      overflow:hidden;
    }
    .panelHeader{
      padding: 14px 16px;
      border-bottom: 1px solid rgba(255,255,255,.10);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
    }
    .tabs{ display:flex; gap: 8px; flex-wrap:wrap; }
    .tab{
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.25);
      font-size: 13px;
      color: rgba(255,255,255,.8);
      cursor:pointer;
    }
    .tab.active{
      border-color: rgba(120,220,255,.45);
      background: rgba(120,220,255,.10);
      color: rgba(255,255,255,.92);
    }
    .panelBody{
      padding: 14px 16px 16px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    .panelBody .block{
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      padding: 14px;
      background: rgba(0,0,0,.22);
    }
    .gradeBig{
      font-size: 72px;
      font-weight: 980;
      letter-spacing: 1px;
      margin: 0;
      line-height: .95;
      text-shadow: 0 20px 80px rgba(0,0,0,.8);
    }
    .scoreSmall{
      margin-top: 10px;
      font-size: 26px;
      font-weight: 900;
      color: rgba(255,255,255,.88);
    }
    .subInfo{
      margin-top: 8px;
      font-size: 14px;
      color: rgba(255,255,255,.78);
    }
    .kvs{
      margin-top: 10px;
      display:flex;
      flex-direction:column;
      gap: 6px;
      color: rgba(255,255,255,.75);
      font-size: 13px;
    }
    .kvs div{
      display:flex;
      justify-content:space-between;
      gap: 10px;
      font-variant-numeric: tabular-nums;
    }

    .panelFooter{
      padding: 12px 16px 14px;
      border-top: 1px solid rgba(255,255,255,.10);
      display:flex;
      justify-content:flex-end;
      gap: 10px;
    }

    @media (max-width: 860px){
      .sidePanel{ display:none; }
      :root{ --h: 660px; }
    }
  </style>
</head>
<body>
  <div class="app" id="app">
    <div class="bg" id="bg"></div>

    <div class="hud">
      <div class="left">
        <div class="badge"><strong>4키</strong> D / F / J / K</div>
        <select id="songSelect"></select>
        <button id="startBtn" class="btnPrimary">시작</button>
        <button id="stopBtn" class="btnDanger">정지</button>
      </div>

      <div class="right">
        <div class="badge mono">BPM <strong id="bpmLabel">—</strong></div>
        <div class="badge mono">OFFSET <strong id="offsetLabel">—</strong>ms</div>
        <div class="badge mono">SCROLL <strong id="scrollLabel">—</strong>ms</div>
      </div>
    </div>

    <div class="stage">
      <div class="gameWrap">
        <div class="laneBoard" id="laneBoard">
          <div class="lanes" id="lanes">
            <div class="lane"></div>
            <div class="lane"></div>
            <div class="lane"></div>
            <div class="lane"></div>
          </div>

          <div class="hitBand"></div>
          <div class="hitLine"></div>

          <div class="keys" id="keys">
            <div class="key">D</div>
            <div class="key">F</div>
            <div class="key">J</div>
            <div class="key">K</div>
          </div>

          <div class="centerUI">
            <div class="judgeBox">
              <div class="judgeText" id="judgeText">Perfect</div>
              <div class="comboText" id="comboText">콤보 0</div>
            </div>
          </div>

          <div class="countdown" id="countdown">3</div>
        </div>

        <div class="sidePanel">
          <div class="card">
            <div class="row"><span>점수</span><strong class="mono" id="scoreText">0</strong></div>
            <div class="row"><span>콤보</span><strong class="mono" id="comboSideText">0</strong></div>
            <div class="row"><span>최고 콤보</span><strong class="mono" id="maxComboSideText">0</strong></div>
            <div class="row"><span>정확도</span><strong class="mono" id="accText">—</strong></div>
          </div>
          <div class="card">
            <div class="row"><span>Perfect</span><strong class="mono" id="pText">0</strong></div>
            <div class="row"><span>Great</span><strong class="mono" id="gText">0</strong></div>
            <div class="row"><span>Good</span><strong class="mono" id="gdText">0</strong></div>
            <div class="row"><span>Miss</span><strong class="mono" id="mText">0</strong></div>
          </div>
          <div class="card">
            <div class="row"><span>팁</span><strong>판정 기준</strong></div>
            <div class="hint">Perfect는 노트가 <b>HIT LINE</b>을 통과하는 순간을 기준으로 판정돼요.</div>
          </div>
        </div>

        <audio id="audio" preload="auto" crossorigin="anonymous"></audio>
      </div>
    </div>

    <div class="footerTools">
      <div class="toolRow">
        <div class="group">
          <button id="genBtn" class="btnPrimary">온셋 기반 자동 채보 생성 (중급+)</button>
          <button id="saveBtn">LocalStorage 저장</button>
          <button id="loadBtn">LocalStorage 불러오기</button>
          <button id="exportBtn">Export JSON</button>
        </div>

        <div class="group">
          <label class="badge mono">BPM <input id="bpmInput" type="number" step="0.1" style="width:90px" /></label>
          <label class="badge mono">OFFSET <input id="offsetInput" type="number" step="1" style="width:90px" /></label>
          <label class="badge mono">SCROLL <input id="scrollInput" type="number" step="10" style="width:110px" /></label>
        </div>
      </div>

      <textarea id="chartBox" spellcheck="false" placeholder="여기에 채보(JSON)를 붙여넣고 저장/불러오기를 할 수 있어요."></textarea>

      <div class="hint">
        ✅ “파일 더블클릭로 실행”은 분석(fetch)이 막힐 수 있어요. VS Code Live Server(추천) / GitHub Pages에서 열어주세요.
      </div>
    </div>

    <div class="modal" id="modal">
      <div class="backdrop"></div>
      <div class="panel">
        <div class="panelHeader">
          <div class="tabs">
            <div class="tab active" data-tab="result">결과</div>
            <div class="tab" data-tab="detail">상세</div>
          </div>
          <button id="closeModalBtn">닫기</button>
        </div>
        <div class="panelBody" id="modalBody"></div>
        <div class="panelFooter">
          <button id="restartBtn" class="btnPrimary">같은 곡 다시</button>
          <button id="backToMenuBtn">닫기</button>
        </div>
      </div>
    </div>

  </div>

<script>
(() => {
  // -----------------------------
  // Songs
  // -----------------------------
  const SONGS = [
    { id:"badguys",    name:"BadGuys",    audio:"assets/audio/BadGuys.mp3",    bg:"assets/bg/bg_BadGuys.png",    bpm:135, offsetMs:0, scrollMs:1700 },
    { id:"missingyou", name:"MissingYou", audio:"assets/audio/MissingYou.mp3", bg:"assets/bg/bg_MissingYou.png", bpm:120, offsetMs:0, scrollMs:1700 },
    { id:"restnpeace", name:"RestNPeace", audio:"assets/audio/RestNPeace.mp3", bg:"assets/bg/bg_RestNPeace.png", bpm:120, offsetMs:0, scrollMs:1700 }
  ];

  // -----------------------------
  // DOM
  // -----------------------------
  const bgEl = document.getElementById("bg");
  const songSelect = document.getElementById("songSelect");
  const startBtn = document.getElementById("startBtn");
  const stopBtn = document.getElementById("stopBtn");
  const genBtn = document.getElementById("genBtn");
  const saveBtn = document.getElementById("saveBtn");
  const loadBtn = document.getElementById("loadBtn");
  const exportBtn = document.getElementById("exportBtn");
  const chartBox = document.getElementById("chartBox");

  const bpmLabel = document.getElementById("bpmLabel");
  const offsetLabel = document.getElementById("offsetLabel");
  const scrollLabel = document.getElementById("scrollLabel");

  const bpmInput = document.getElementById("bpmInput");
  const offsetInput = document.getElementById("offsetInput");
  const scrollInput = document.getElementById("scrollInput");

  const keysEl = document.getElementById("keys");
  const keyEls = Array.from(keysEl.querySelectorAll(".key"));
  const laneEls = Array.from(document.querySelectorAll(".lane"));
  const laneBoard = document.getElementById("laneBoard");

  const judgeTextEl = document.getElementById("judgeText");
  const comboTextEl = document.getElementById("comboText");
  const scoreTextEl = document.getElementById("scoreText");
  const comboSideTextEl = document.getElementById("comboSideText");
  const maxComboSideTextEl = document.getElementById("maxComboSideText");
  const accTextEl = document.getElementById("accText");
  const pText = document.getElementById("pText");
  const gText = document.getElementById("gText");
  const gdText = document.getElementById("gdText");
  const mText = document.getElementById("mText");

  const countdownEl = document.getElementById("countdown");
  const audioEl = document.getElementById("audio");

  const modal = document.getElementById("modal");
  const modalBody = document.getElementById("modalBody");
  const closeModalBtn = document.getElementById("closeModalBtn");
  const restartBtn = document.getElementById("restartBtn");
  const backToMenuBtn = document.getElementById("backToMenuBtn");
  const tabEls = Array.from(document.querySelectorAll(".tab"));

  // -----------------------------
  // State
  // -----------------------------
  const KEYMAP = { "KeyD": 0, "KeyF": 1, "KeyJ": 2, "KeyK": 3 };
  let currentSong = SONGS[0];

  // chart format:
  // { version, songId, audio, offsetMs, scrollMs, bpm, notes:[{t,lane}] }
  let chart = null;
  window.chart = null;

  let running = false;
  let rafId = 0;

  let preRolling = false;
  let goPerf = 0;

  const notePool = [];
  const activeNotesDOM = new Map();

  const stats = {
    score: 0,
    combo: 0,
    maxCombo: 0,
    perfect: 0,
    great: 0,
    good: 0,
    miss: 0,
    total: 0,
    hit: 0
  };

  const JUDGE = [
    { name: "Perfect", win: 45,  color: "var(--accent)", score: 1000 },
    { name: "Great",   win: 85,  color: "var(--good)",  score: 700  },
    { name: "Good",    win: 125, color: "var(--warn)",  score: 400  },
    { name: "Miss",    win: 170, color: "var(--bad)",   score: 0    }
  ];

  const hitLock = new Array(4).fill(0);
  const HIT_LOCK_MS = 45;

  let countdownTimer = 0;

  // -----------------------------
  // Helpers
  // -----------------------------
  function setBackground(url){
    bgEl.style.backgroundImage = `url("${url}")`;
    bgEl.style.backgroundSize = "cover";
    bgEl.style.backgroundPosition = "center";
  }
  function fmt(n){ return (n|0).toString().replace(/\B(?=(\d{3})+(?!\d))/g, ","); }

  function resetStats(){
    stats.score = 0;
    stats.combo = 0;
    stats.maxCombo = 0;
    stats.perfect = 0;
    stats.great = 0;
    stats.good = 0;
    stats.miss = 0;
    stats.total = 0;
    stats.hit = 0;
    updateHUD();
  }

  function updateHUD(){
    scoreTextEl.textContent = fmt(stats.score);
    comboSideTextEl.textContent = String(stats.combo);
    maxComboSideTextEl.textContent = String(stats.maxCombo);

    pText.textContent = String(stats.perfect);
    gText.textContent = String(stats.great);
    gdText.textContent = String(stats.good);
    mText.textContent = String(stats.miss);

    const acc = stats.total > 0 ? (stats.hit / stats.total) : 0;
    accTextEl.textContent = stats.total ? `${(acc*100).toFixed(1)}%` : "—";

    bpmLabel.textContent = chart ? chart.bpm : currentSong.bpm;
    offsetLabel.textContent = chart ? chart.offsetMs : currentSong.offsetMs;
    scrollLabel.textContent = chart ? chart.scrollMs : currentSong.scrollMs;
  }

  function flashJudge(name, color){
    judgeTextEl.textContent = name;
    judgeTextEl.style.color = color;
    judgeTextEl.classList.add("show");
    setTimeout(() => judgeTextEl.classList.remove("show"), 160);

    comboTextEl.textContent = `콤보 ${stats.combo}`;
    if(stats.combo > 0){
      comboTextEl.classList.add("show");
      setTimeout(() => comboTextEl.classList.remove("show"), 260);
    }
  }

  function clearNotesDOM(){
    for(const [, el] of activeNotesDOM){
      el.remove();
      notePool.push(el);
    }
    activeNotesDOM.clear();
  }

  function getNoteEl(){
    const el = notePool.pop() || document.createElement("div");
    el.className = "note";
    return el;
  }

  function nowMs(){
    if(!running) return 0;

    // ✅ 카운트다운 중: GO 시점 기준으로 음수 시간(프리롤)
    if(preRolling){
      return (performance.now() - goPerf); // GO 전엔 음수, GO 순간 0
    }
    return (audioEl.currentTime * 1000);
  }

  function chartTimeToScreenY(noteTms, currentTms){
    const dt = noteTms - currentTms;
    const progress = 1 - (dt / chart.scrollMs);
    const yStart = -50;
    const yEnd = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--hitY"));
    return yStart + (yEnd - yStart) * progress;
  }

  function laneX(laneIndex){
    const laneW = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--laneW"));
    const laneGap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--laneGap"));
    const totalW = laneW*4 + laneGap*3;
    const boardW = laneBoard.clientWidth;
    const left = (boardW - totalW)/2;
    return left + laneIndex*(laneW + laneGap);
  }

  function setKeyActive(lane, on){
    const el = keyEls[lane];
    if(el) el.classList.toggle("active", !!on);
    const le = laneEls[lane];
    if(le) le.classList.toggle("lit", !!on);
  }

  // -----------------------------
  // Countdown
  // -----------------------------
  function showCountdown(show, text=""){
    countdownEl.classList.toggle("show", !!show);
    if(show) countdownEl.textContent = text;
  }

  async function runCountdown(seconds=3){
    clearTimeout(countdownTimer);
    for(let s=seconds; s>=1; s--){
      showCountdown(true, String(s));
      await new Promise(r => countdownTimer=setTimeout(r, 950));
    }
    showCountdown(true, "GO!");
    await new Promise(r => countdownTimer=setTimeout(r, 300));
    showCountdown(false);
  }

  // -----------------------------
  // Modal
  // -----------------------------
  function openModal(tab="result"){
    modal.classList.add("show");
    setActiveTab(tab);
    renderModal(tab);
  }
  function closeModal(){ modal.classList.remove("show"); }
  function setActiveTab(tab){
    tabEls.forEach(t => t.classList.toggle("active", t.dataset.tab === tab));
  }

  function gradeFromAcc(acc){
    if(acc >= 0.98) return "S";
    if(acc >= 0.95) return "A";
    if(acc >= 0.90) return "B";
    if(acc >= 0.80) return "C";
    return "D";
  }

  function renderModal(tab){
    const acc = stats.total ? (stats.hit / stats.total) : 0;
    const grade = gradeFromAcc(acc);
    const score = stats.score;

    if(tab === "result"){
      modalBody.innerHTML = `
        <div class="block">
          <p class="gradeBig">${grade}</p>
          <div class="subInfo">정확도 <strong>${(acc*100).toFixed(1)}%</strong> · Max Combo <strong>${stats.maxCombo}</strong></div>
          <div class="scoreSmall mono">${fmt(score)}</div>
          <div class="kvs">
            <div><span>노트 수</span><strong class="mono">${stats.total}</strong></div>
            <div><span>곡</span><strong>${currentSong.name}</strong></div>
            <div><span>설정</span><strong class="mono">BPM ${chart.bpm} · OFF ${chart.offsetMs} · SCR ${chart.scrollMs}</strong></div>
          </div>
        </div>
        <div class="block">
          <div class="kvs">
            <div><span>Perfect</span><strong class="mono">${stats.perfect}</strong></div>
            <div><span>Great</span><strong class="mono">${stats.great}</strong></div>
            <div><span>Good</span><strong class="mono">${stats.good}</strong></div>
            <div><span>Miss</span><strong class="mono">${stats.miss}</strong></div>
          </div>
        </div>
      `;
    } else {
      modalBody.innerHTML = `
        <div class="block" style="grid-column:1 / -1;">
          <div class="kvs">
            <div><span>점수</span><strong>Perfect 1000 / Great 700 / Good 400</strong></div>
            <div><span>콤보</span><strong>combo × 0.4 (최대 1.4배)</strong></div>
            <div><span>저장</span><strong>곡별 LocalStorage 저장</strong></div>
          </div>
        </div>
      `;
    }
  }

  // -----------------------------
  // Chart load/save
  // -----------------------------
  function defaultChartFor(song){
    return {
      version: 1,
      songId: song.id,
      audio: song.audio,
      offsetMs: song.offsetMs,
      scrollMs: song.scrollMs,
      bpm: song.bpm,
      notes: []
    };
  }

  function storageKey(songId){ return `rhythm_chart_${songId}`; }
  function storageSettingsKey(songId){ return `rhythm_settings_${songId}`; }

  function saveToLocal(){
    if(!chart) return;
    localStorage.setItem(storageKey(chart.songId), JSON.stringify(chart));
    localStorage.setItem(storageSettingsKey(chart.songId), JSON.stringify({
      bpm: chart.bpm,
      offsetMs: chart.offsetMs,
      scrollMs: chart.scrollMs
    }));
    toast(`저장 완료: ${currentSong.name}`);
  }

  function loadFromLocal(){
    const raw = localStorage.getItem(storageKey(currentSong.id));
    const rawSet = localStorage.getItem(storageSettingsKey(currentSong.id));
    if(raw){
      try{
        const obj = JSON.parse(raw);
        chart = normalizeChart(obj, currentSong);
        window.chart = chart;
        applyChartToUI();
        toast(`불러오기 완료: ${currentSong.name}`);
        return;
      }catch(e){}
    }
    if(rawSet){
      try{
        const s = JSON.parse(rawSet);
        currentSong.bpm = Number(s.bpm) || currentSong.bpm;
        currentSong.offsetMs = Number(s.offsetMs) || currentSong.offsetMs;
        currentSong.scrollMs = Number(s.scrollMs) || currentSong.scrollMs;
      }catch(e){}
    }
    chart = defaultChartFor(currentSong);
    applyChartToUI();
    toast(`저장된 채보 없음: 기본값 로드`);
  }

  // ✅ tap-only normalize: 기존 hold/type/dur가 있어도 전부 무시
  function normalizeChart(obj, song){
    const safe = defaultChartFor(song);
    safe.version = obj.version ?? safe.version;
    safe.songId = song.id;
    safe.audio = song.audio;
    safe.offsetMs = Number(obj.offsetMs ?? song.offsetMs) || 0;
    safe.scrollMs = Number(obj.scrollMs ?? song.scrollMs) || 1700;
    safe.bpm = Number(obj.bpm ?? song.bpm) || song.bpm;

    safe.notes = Array.isArray(obj.notes) ? obj.notes
      .filter(n => Number.isFinite(n.t) && Number.isFinite(n.lane))
      .map(n => ({
        t: Math.max(0, Math.round(n.t)),
        lane: Math.max(0, Math.min(3, Math.round(n.lane)))
      }))
      .sort((a,b)=>a.t-b.t || a.lane-b.lane)
      : [];

    safe.notes.forEach(n => {
      delete n._hit;
      delete n._hitStart;
      delete n._holding;
      delete n._releaseT;
    });

    return safe;
  }

  function applyChartToUI(){
    setBackground(currentSong.bg);
    audioEl.src = currentSong.audio;

    bpmInput.value = chart.bpm;
    offsetInput.value = chart.offsetMs;
    scrollInput.value = chart.scrollMs;

    chartBox.value = JSON.stringify(chart, null, 2);
    updateHUD();
  }

  // -----------------------------
  // Toast
  // -----------------------------
  let toastTimer = 0;
  function toast(msg){
    clearTimeout(toastTimer);
    judgeTextEl.textContent = msg;
    judgeTextEl.style.color = "rgba(255,255,255,.92)";
    judgeTextEl.classList.add("show");
    toastTimer = setTimeout(()=>judgeTextEl.classList.remove("show"), 900);
  }

  // -----------------------------
  // Gameplay
  // -----------------------------
  async function startGame(){
    if(running) return;
    if(!chart) chart = defaultChartFor(currentSong);

    chart.bpm = Number(bpmInput.value) || chart.bpm;
    chart.offsetMs = Number(offsetInput.value) || 0;
    chart.scrollMs = Number(scrollInput.value) || chart.scrollMs;
    updateHUD();

    if(!chart.notes || chart.notes.length === 0){
      toast("채보가 비어있어요. 먼저 자동 생성(온셋) 해주세요!");
      return;
    }

    resetStats();
    clearNotesDOM();

    audioEl.pause();
    audioEl.currentTime = 0;

    // ✅ 프리롤: 카운트다운 동안에도 노트가 내려오게
    running = true;
    preRolling = true;

    const COUNTDOWN_TOTAL_MS = 3150; // 3*950 + 300
    goPerf = performance.now() + COUNTDOWN_TOTAL_MS;

    rafId = requestAnimationFrame(loop);

    await runCountdown(3);

    preRolling = false;

    try{
      await audioEl.play();
    }catch(err){
      running = false;
      toast("오디오 재생 실패: 브라우저 자동재생 제한일 수 있어요.");
      return;
    }

    rafId = requestAnimationFrame(loop);
  }

  function stopGame(showResult=false){
    if(!running && !showResult) return;
    running = false;
    cancelAnimationFrame(rafId);
    rafId = 0;

    audioEl.pause();
    for(let i=0;i<4;i++) setKeyActive(i,false);

    if(showResult) openModal("result");
  }

  function loop(){
    if(!running) return;

    const tms = nowMs() - chart.offsetMs;
    const laneW = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--laneW"));

    const appearFrom = tms - 160;
    const appearTo = tms + chart.scrollMs + 360;

    for(let i=0; i<chart.notes.length; i++){
      const n = chart.notes[i];
      if(n.t < appearFrom) continue;
      if(n.t > appearTo) break;

      let el = activeNotesDOM.get(i);
      if(!el){
        el = getNoteEl();
        activeNotesDOM.set(i, el);
        laneBoard.appendChild(el);
      }

      const y = chartTimeToScreenY(n.t, tms);
      const x = laneX(n.lane);

      el.style.left = `${x + 10}px`;
      el.style.width = `${laneW - 20}px`;
      el.style.height = `${parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--noteH"))}px`;
      el.style.top = `${y}px`;
      el.style.display = "";

      // ✅ 히트박스(판정 근처) 들어오면 강조
      const dt = n.t - tms;
      el.classList.toggle("inWindow", Math.abs(dt) <= 140 && !n._hit);

      const prev = chart.notes[i-1];
      const next = chart.notes[i+1];
      const isChord = (prev && prev.t === n.t) || (next && next.t === n.t);
      el.classList.toggle("chord", !!isChord);
    }

    const missWin = JUDGE[JUDGE.length-1].win;

    for(const [i, el] of Array.from(activeNotesDOM.entries())){
      const n = chart.notes[i];
      if(tms - n.t > missWin){
        if(!n._hit){
          n._hit = true;
          stats.total++;
          stats.miss++;
          stats.combo = 0;
          flashJudge("Miss", "var(--bad)");
          updateHUD();
        }
        el.classList.add("missed");
        activeNotesDOM.delete(i);
        setTimeout(() => {
          el.remove();
          notePool.push(el);
        }, 140);
      }
    }

    const durMs = Number.isFinite(audioEl.duration) ? audioEl.duration * 1000 : Infinity;
    if(audioEl.ended || (durMs !== Infinity && (audioEl.currentTime * 1000) >= durMs - 5)){
      stopGame(true);
      return;
    }
    if(durMs === Infinity && tms > (chart.notes[chart.notes.length-1]?.t ?? 0) + 5000){
      stopGame(true);
      return;
    }

    rafId = requestAnimationFrame(loop);
  }

  function applyJudgeResult(judge){
    stats.total++;
    if(judge.name !== "Miss"){
      stats.hit++;
      stats.combo++;
      stats.maxCombo = Math.max(stats.maxCombo, stats.combo);

      const mult = 1 + Math.min(0.4, stats.combo * 0.004);
      stats.score += Math.round(judge.score * mult);

      if(judge.name === "Perfect") stats.perfect++;
      else if(judge.name === "Great") stats.great++;
      else if(judge.name === "Good") stats.good++;
    } else {
      stats.miss++;
      stats.combo = 0;
    }

    flashJudge(judge.name, judge.color);
    updateHUD();
  }

  function judgeLanePress(lane){
    if(!running || !chart?.notes?.length) return;

    const tms = nowMs() - chart.offsetMs;

    if(Math.abs(tms - hitLock[lane]) < HIT_LOCK_MS) return;
    hitLock[lane] = tms;

    const missWin = JUDGE[JUDGE.length-1].win;
    const minT = tms - missWin;
    const maxT = tms + missWin;

    let bestIdx = -1;
    let bestAbs = Infinity;

    let lo = 0, hi = chart.notes.length-1, start = 0;
    while(lo <= hi){
      const mid = (lo + hi) >> 1;
      if(chart.notes[mid].t < minT) lo = mid + 1;
      else { start = mid; hi = mid - 1; }
    }

    for(let i = start; i < chart.notes.length; i++){
      const n = chart.notes[i];
      if(n.t > maxT) break;
      if(n._hit) continue;
      if(n.lane !== lane) continue;

      const d = Math.abs(n.t - tms);
      if(d < bestAbs){
        bestAbs = d;
        bestIdx = i;
      }
    }

    if(bestIdx === -1){
      applyJudgeResult(JUDGE[JUDGE.length-1]);
      return;
    }

    const n = chart.notes[bestIdx];
    const d = Math.abs(n.t - tms);

    let judge = JUDGE[JUDGE.length-1];
    for(const j of JUDGE){
      if(d <= j.win){ judge = j; break; }
    }

    n._hit = true;
    applyJudgeResult(judge);

    const el = activeNotesDOM.get(bestIdx);
    if(el){
      el.classList.add("hit");
      if(judge.name === "Perfect") el.classList.add("pf");
      else if(judge.name === "Great") el.classList.add("gr");
      else if(judge.name === "Good") el.classList.add("gd");
      el.classList.remove("inWindow");
      activeNotesDOM.delete(bestIdx);
      setTimeout(() => {
        el.remove();
        notePool.push(el);
      }, 140);
    }
  }

  // -----------------------------
  // ✅ Onset-based chart generation (tap-only)
  // -----------------------------
  async function generateOnsetChartIntermediate(song){
    const bpm = Number(bpmInput.value) || song.bpm;
    const scrollMs = Number(scrollInput.value) || song.scrollMs;

    // ===== knobs =====
    const WANT_NOTE_MULT = 1.18;      // 전체 노트 +18% 목표
    const MIN_GAP_MS = 155;           // 너무 촘촘한 컷 완화
    const SNAP_STRONG_TOL = 34;
    const SNAP_WEAK_TOL = 18;
    const STRONG_KEEP = 0.90;         // 기준

    toast("오디오 분석 중… (온셋 감지)");
    const resp = await fetch(song.audio);
    if(!resp.ok) throw new Error("fetch 실패");
    const buf = await resp.arrayBuffer();

    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const audioBuffer = await ctx.decodeAudioData(buf);

    const ch0 = audioBuffer.getChannelData(0);
    const ch1 = audioBuffer.numberOfChannels > 1 ? audioBuffer.getChannelData(1) : null;
    const len = audioBuffer.length;
    const sr = audioBuffer.sampleRate;

    const frame = 2048;
    const hop = 512;
    const eps = 1e-12;

    // --- dx RMS ---
    const rms = [];
    let prev = 0;
    for(let i=0; i+frame < len; i += hop){
      let s = 0;
      for(let j=0; j<frame; j++){
        const x = ch1 ? 0.5*(ch0[i+j] + ch1[i+j]) : ch0[i+j];
        const dx = x - prev;
        prev = x;
        const v = Math.abs(dx);
        s += v*v;
      }
      rms.push(Math.sqrt(s / frame + eps));
    }

    // smooth
    const sm = new Array(rms.length).fill(0);
    const win = 6;
    for(let i=0; i<rms.length; i++){
      let a=0, c=0;
      for(let k=-win; k<=win; k++){
        const idx = i+k;
        if(idx>=0 && idx<rms.length){ a += rms[idx]; c++; }
      }
      sm[i] = a / c;
    }

    // novelty
    const nov = new Array(sm.length).fill(0);
    for(let i=1; i<sm.length; i++){
      const d = sm[i] - sm[i-1];
      nov[i] = d > 0 ? d : 0;
    }

    // energy gate baseline
    const rmsSorted = [...sm].sort((a,b)=>a-b);
    const rmsMed = rmsSorted[Math.floor(rmsSorted.length*0.50)] || 0;
    const rmsP70 = rmsSorted[Math.floor(rmsSorted.length*0.70)] || rmsMed;
    let energyFloor = Math.max(rmsMed * 1.15, rmsP70 * 0.35, 0.002);

    // MAD thr baseline
    const novSorted = [...nov].sort((a,b)=>a-b);
    const med = novSorted[Math.floor(novSorted.length*0.5)] || 0;
    const absDev = novSorted.map(v => Math.abs(v - med)).sort((a,b)=>a-b);
    const mad = absDev[Math.floor(absDev.length*0.5)] || 0;

    function buildCandidates(thrMul, energyMul){
      const ignoreHeadMs = 350;

      // tail cut
      const kTail = 1.05;
      let lastMusicFrame = sm.length - 1;
      for(let i=sm.length-1; i>=0; i--){
        if(sm[i] >= energyFloor * kTail){
          lastMusicFrame = i;
          break;
        }
      }
      const lastMusicMs = (lastMusicFrame * hop / sr) * 1000;
      const hardTailCutMs = Math.max(ignoreHeadMs + 500, lastMusicMs + 120);
      const maxTms = Math.min(audioBuffer.duration * 1000, hardTailCutMs);

      const thr = med + thrMul * mad;
      const eFloor = energyFloor * energyMul;

      function refineTimeMs(tMs){
        const radiusFrames = 3;
        const center = Math.round((tMs/1000) * sr / hop);
        let bestI = center, bestV = -Infinity;
        for(let k=-radiusFrames; k<=radiusFrames; k++){
          const ii = center + k;
          if(ii <= 1 || ii >= nov.length-1) continue;
          const v = nov[ii];
          if(v > bestV){ bestV = v; bestI = ii; }
        }
        return (bestI * hop / sr) * 1000;
      }

      const out = [];
      for(let i=2; i<nov.length-2; i++){
        const v = nov[i];
        if(v < thr) continue;
        if(sm[i] < eFloor) continue;
        if(!(v >= nov[i-1] && v >= nov[i+1] && v >= nov[i-2] && v >= nov[i+2])) continue;

        let t = (i * hop / sr) * 1000;
        t = refineTimeMs(t);

        if(t < ignoreHeadMs) continue;
        if(t > maxTms) continue;

        out.push({ t, strength: v });
      }
      return { candidates: out, maxTms, ignoreHeadMs };
    }

    // 1차
    let pack = buildCandidates(3.0, 1.0);

    // 후보 적으면 완화
    const durSec = audioBuffer.duration || 1;
    const candRate1 = pack.candidates.length / durSec;
    if(candRate1 < 2.1){
      pack = buildCandidates(2.55, 0.94);
    }
    const candRate2 = pack.candidates.length / durSec;
    if(candRate2 < 2.0){
      pack = buildCandidates(2.25, 0.90);
    }

    const { candidates, maxTms, ignoreHeadMs } = pack;

    // normalize strength
    let maxS = 0;
    for(const c of candidates) maxS = Math.max(maxS, c.strength);
    const candN = candidates.map(c => ({
      t: c.t,
      strength: c.strength,
      sN: maxS > 0 ? (c.strength / maxS) : 0
    }));

    // 2초 창 최소 2개
    (function enforceLightDensity(){
      const WIN_MS = 2000;
      const MIN_PER_WIN = 2;
      const bins = new Map();
      for(const c of candN){
        const b = Math.floor(c.t / WIN_MS);
        if(!bins.has(b)) bins.set(b, []);
        bins.get(b).push(c);
      }
      const forced = [];
      for(const [, arr] of bins){
        arr.sort((a,b)=>b.strength-a.strength);
        forced.push(...arr.slice(0, MIN_PER_WIN));
      }
      const key = x => Math.round(x.t);
      const forcedSet = new Set(forced.map(key));
      const out = [];
      for(const c of candN){
        if(forcedSet.has(key(c))) continue;
        out.push(c);
      }
      candN.length = 0;
      candN.push(...out, ...forced);
    })();

    const candRate = candN.length / durSec;
    const autoBoost =
      candRate < 2.0 ? 1.24 :
      candRate < 2.5 ? 1.16 :
      1.00;

    const baseNPS = 2.60;
    const targetNPS = baseNPS * autoBoost * WANT_NOTE_MULT;
    const maxNotes = Math.floor(durSec * targetNPS);

    // select
    const selected = [];
    candN.sort((a,b)=>b.strength-a.strength);
    for(const c of candN){
      if(selected.length >= maxNotes) break;
      if(selected.some(s => Math.abs(s.t - c.t) < MIN_GAP_MS)) continue;
      selected.push(c);
    }
    selected.sort((a,b)=>a.t-b.t);

    // snap strong only
    const beatMs = 60000 / bpm;
    const sub = [1, 0.5];
    function snapStrong(t, sN){
      const tol = (sN >= STRONG_KEEP) ? SNAP_STRONG_TOL : SNAP_WEAK_TOL;
      let best = t, bestD = Infinity;
      for(const s of sub){
        const step = beatMs * s;
        const k = Math.round(t / step);
        const tt = k * step;
        const d = Math.abs(tt - t);
        if(d < bestD){ bestD = d; best = tt; }
      }
      return bestD <= tol ? best : t;
    }

    const times = selected.map(o => Math.max(0, Math.round(snapStrong(o.t, o.sN))));

    // lanes + chords
    const notes = [];
    let lastLane = 0;
    let side = 0;

    function chooseLane(){
      side = 1 - side;
      const lanes = side === 0 ? [0,1] : [2,3];
      let lane = lanes[Math.random() < 0.55 ? 0 : 1];
      if(lane === lastLane) lane = (lane === lanes[0]) ? lanes[1] : lanes[0];
      lastLane = lane;
      return lane;
    }

    function recentNoteCount(t){
      const win = 1200;
      let c = 0;
      for(let i = notes.length-1; i>=0; i--){
        if(t - notes[i].t > win) break;
        c++;
      }
      return c;
    }

    function nearBeat(t){
      const m4 = Math.abs(t - Math.round(t/beatMs)*beatMs);
      const m8 = Math.abs(t - Math.round(t/(beatMs*0.5))*(beatMs*0.5));
      return Math.min(m4, m8);
    }

    let lastChordT = -99999;
    const chordMinGap = 480;
    const endChordBanMs = 1200;

    const sparseBoost =
      candRate < 2.2 ? 1.55 :
      candRate < 2.8 ? 1.25 :
      1.00;

    for(let i=0; i<times.length; i++){
      const t = times[i];
      if(t > maxTms) continue;
      if(notes.length && notes[notes.length-1].t === t) continue;

      const lane = chooseLane();
      notes.push({ t, lane });

      const sN = selected[i]?.sN ?? 0;
      const isStrong = sN >= STRONG_KEEP;

      const beatDist = nearBeat(t);
      const beatOk = beatDist <= 42;
      const notEnding = (maxTms - t) > endChordBanMs;

      const dens = recentNoteCount(t);
      const densFactor =
        dens >= 7 ? 0.10 :
        dens >= 6 ? 0.18 :
        dens >= 5 ? 0.30 :
        dens >= 4 ? 0.55 :
        1.00;
      const denseNow = dens >= 6;

      const baseProb = isStrong ? 0.42 * sparseBoost : 0.12;
      let prob = baseProb * densFactor;

      if(!isStrong && beatDist <= 30){
        prob *= 1.6;
      }

      if(beatOk && notEnding && !denseNow && (t - lastChordT >= chordMinGap) && Math.random() < prob){
        const pairs = { 0:[2,3], 1:[3,2], 2:[0,1], 3:[1,0] };
        const lane2 = pairs[lane][Math.random() < 0.65 ? 0 : 1];
        notes.push({ t, lane: lane2 });
        lastChordT = t;
      }
    }

    notes.sort((a,b)=>a.t-b.t || a.lane-b.lane);

    // very long gap fill
    (function hardFillVeryLongGaps(){
      const HARD_GAP_MS = 3200;
      const STEP = beatMs * 0.5;
      const MAX_ADD = 8;
      const timeSet = new Set(notes.map(n => n.t));

      function add(t){
        const tt = Math.round(t);
        if(tt > maxTms) return false;
        if(timeSet.has(tt)) return false;
        notes.push({ t: tt, lane: chooseLane() });
        timeSet.add(tt);
        return true;
      }

      notes.sort((a,b)=>a.t-b.t || a.lane-b.lane);
      for(let i=0; i<notes.length-1; i++){
        const a = notes[i], b = notes[i+1];
        const gap = b.t - a.t;
        if(gap < HARD_GAP_MS) continue;

        let added = 0;
        for(let t = a.t + STEP; t <= b.t - STEP; t += STEP){
          if(added >= MAX_ADD) break;
          if(add(t)) added++;
        }
      }
      notes.sort((a,b)=>a.t-b.t || a.lane-b.lane);
    })();

    // same-lane near duplicates
    (function removeNearDuplicates(){
      notes.sort((a,b)=>a.t-b.t || a.lane-b.lane);
      const out = [];
      const lastT = [ -1e9, -1e9, -1e9, -1e9 ];
      const minSameLaneGap = 120;
      for(const n of notes){
        if(n.t - lastT[n.lane] < minSameLaneGap) continue;
        out.push(n);
        lastT[n.lane] = n.t;
      }
      notes.length = 0;
      notes.push(...out);
    })();

    const offsetMs = Number(offsetInput.value) || song.offsetMs || 0;

    return {
      version: 12,
      songId: song.id,
      audio: song.audio,
      offsetMs,
      scrollMs,
      bpm,
      notes
    };
  }

  // -----------------------------
  // Export
  // -----------------------------
  function exportJSON(){
    if(!chart) return;
    const blob = new Blob([JSON.stringify(chart, null, 2)], {type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = `${chart.songId}_chart.json`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(a.href);
  }

  // -----------------------------
  // Wiring
  // -----------------------------
  function initSongSelect(){
    songSelect.innerHTML = "";
    for(const s of SONGS){
      const opt = document.createElement("option");
      opt.value = s.id;
      opt.textContent = s.name;
      songSelect.appendChild(opt);
    }
    songSelect.value = currentSong.id;
  }

  function setSongById(id){
    const s = SONGS.find(x => x.id === id) || SONGS[0];
    currentSong = s;
    setBackground(s.bg);
    audioEl.src = s.audio;
    loadFromLocal();
  }

  songSelect.addEventListener("change", () => {
    stopGame(false);
    setSongById(songSelect.value);
  });

  startBtn.addEventListener("click", () => startGame());
  stopBtn.addEventListener("click", () => stopGame(false));

  genBtn.addEventListener("click", async () => {
    stopGame(false);
    try{
      genBtn.disabled = true;
      genBtn.textContent = "분석 중…";
      const newChart = await generateOnsetChartIntermediate(currentSong);
      chart = normalizeChart(newChart, currentSong);
      window.chart = chart;
      applyChartToUI();
      saveToLocal();
      toast(`생성 완료: 노트 ${chart.notes.length}개`);
    } catch(e){
      console.error(e);
      toast("생성 실패: file://로 열었거나 fetch가 막혔을 수 있어요. Live Server/GitHub Pages로 실행해줘!");
    } finally {
      genBtn.disabled = false;
      genBtn.textContent = "온셋 기반 자동 채보 생성 (중급+)";
    }
  });

  saveBtn.addEventListener("click", () => {
    try{
      const obj = JSON.parse(chartBox.value);
      chart = normalizeChart(obj, currentSong);
      window.chart = chart;
      saveToLocal();
      applyChartToUI();
    }catch(e){
      toast("저장 실패: JSON 형식이 올바른지 확인해줘!");
    }
  });

  loadBtn.addEventListener("click", () => loadFromLocal());
  exportBtn.addEventListener("click", () => exportJSON());

  function syncInputs(){
    if(!chart) chart = defaultChartFor(currentSong);
    chart.bpm = Number(bpmInput.value) || chart.bpm;
    chart.offsetMs = Number(offsetInput.value) || 0;
    chart.scrollMs = Number(scrollInput.value) || chart.scrollMs;
    updateHUD();
    chartBox.value = JSON.stringify(chart, null, 2);
  }
  bpmInput.addEventListener("change", syncInputs);
  offsetInput.addEventListener("change", syncInputs);
  scrollInput.addEventListener("change", syncInputs);

  window.addEventListener("keydown", (e) => {
    if(e.repeat) return;

    if(e.code === "BracketLeft"){
      const d = e.shiftKey ? -2 : -10;
      offsetInput.value = (Number(offsetInput.value)||0) + d;
      syncInputs();
      toast(`OFFSET ${offsetInput.value}ms`);
      return;
    }
    if(e.code === "BracketRight"){
      const d = e.shiftKey ? 2 : 10;
      offsetInput.value = (Number(offsetInput.value)||0) + d;
      syncInputs();
      toast(`OFFSET ${offsetInput.value}ms`);
      return;
    }

    const lane = KEYMAP[e.code];
    if(lane === undefined) return;

    setKeyActive(lane, true);
    judgeLanePress(lane);
  });

  // ✅ tap-only: keyup은 이펙트만 끔
  window.addEventListener("keyup", (e) => {
    const lane = KEYMAP[e.code];
    if(lane === undefined) return;
    setKeyActive(lane, false);
  });

  closeModalBtn.addEventListener("click", closeModal);
  backToMenuBtn.addEventListener("click", closeModal);
  restartBtn.addEventListener("click", () => {
    closeModal();
    startGame();
  });

  tabEls.forEach(t => {
    t.addEventListener("click", () => {
      setActiveTab(t.dataset.tab);
      renderModal(t.dataset.tab);
    });
  });

  audioEl.addEventListener("ended", () => {
    if(running) stopGame(true);
  });

  initSongSelect();
  setSongById(currentSong.id);
  showCountdown(false);

})();
</script>
</body>
</html>
